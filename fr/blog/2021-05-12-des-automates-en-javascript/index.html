<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Des automates en JavaScript · Gautier Ben Aïm</title><meta name="description" content="Un tutoriel sur les bases du JavaScript asynchrone (async/await), suivi d&#39;un exemple avancé : la créations d&#39;automates."><link rel="stylesheet" href="/404.94b13657.css"><link rel="stylesheet" href="/blog/2021-05-10-guide-graphique-un-article-au-titre-beaucoup-trop-long/index.dad68e9b.css"><link rel="icon shortcut" href="/favicon.f6b5eb08.ico" type="image/x-icon"><link rel="manifest" href="/up_/assets/app.webmanifest"><meta property="og:image" content="/portfolio.50b1f99e.png"></head><body> <nav class="site-nav"> <ul><li><a href="/fr/">Accueil</a></li> <li><a href="/fr/blog/">Blog</a></li> <li><a href="/fr/about/">À propos</a></li></ul> </nav> <main> <h1 class="section-title">Des automates en JavaScript</h1> <div class="markdown-body"> <div class="_sticky-wrapper -left"> <aside class="post-aside"> <p class="description">Un tutoriel sur les bases du JavaScript asynchrone (async/await), suivi d&#39;un exemple avancé : la créations d&#39;automates.</p> <img src="/me.92881bbb.jpg" alt="A picture of me" class="picture" width="48" height="48"> <p class="meta"> <strong>Gautier</strong> · <time datetime="2021-05-12T00:00:00Z">12 mai 2021</time> · 2136 mots </p> <ul class="tag-list"><li class="tag"> <span class="span">JavaScript</span> </li><li class="tag"> <span class="span">async</span> </li> </ul> </aside> </div> <nav class="table-of-contents"> <div class="toc"> <ol><li><a href="#les-bases"> Les bases</a><ol><li><a href="#comment-accéder-à-un-résultat-enveloppé-par-une-promesse"> Comment accéder à un résultat enveloppé par une promesse ?</a></li><li><a href="#renvoyer-explicitement-une-promesse"> Renvoyer explicitement une promesse</a></li><li><a href="#await"> await</a></li></ol></li><li><a href="#bon-ok-mais-ensuite"> Bon ok, mais ensuite ?</a></li><li><a href="#transformer-settimeout-en-fonction-await-able"> Transformer setTimeout en fonction await-able</a></li><li><a href="#un-automate-à-état"> Un automate à état</a></li><li><a href="#encore-plus-loin"> Encore plus loin</a></li></ol></div> </nav> <h2 id="les-bases"><a class="header-anchor" href="#les-bases"> #</a> Les bases</h2> <p>Commençons par définir une fonction des plus simples : une somme entre deux entiers.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Rien de spécial lorqu’on l’appelle ; la somme de 1 et 2 est 3.</p> <p>Et si, sans rien changer d’autre, on rajoute le mot-clé <code>async</code> à notre fonction ?</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// Promise { &lt;state>: "fulfilled", &lt;value>: 3 }</span></code></pre> <p>Cette fois-ci, la fonction ne renvoie pas 3 directement, mais un object bizarre nommé <code>Promise</code> qui semble contenir la valeur 3. <strong>Une promesse est un objet qui enveloppe un résultat qui sera renvoyé dans le futur.</strong> Lorsque vous recevez un objet <code>Promise</code>, le résultat peut déjà être disponible (c’est le cas pour notre fonction <code>sum</code>), ou bientôt disponible (on y vient).</p> <h3 id="comment-accéder-à-un-résultat-enveloppé-par-une-promesse"><a class="header-anchor" href="#comment-accéder-à-un-résultat-enveloppé-par-une-promesse"> #</a> Comment accéder à un résultat enveloppé par une promesse ?</h3> <p>Le moyen le plus simple est de définir une fonction de rappel (<em>callback</em>) à appeler quand le résultat est disponible. On donne la fonction de rappel à la méthode <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">result</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>result<span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Ainsi, notre <code>console.log</code> est appelé dès que le résultat est disponible, de façon <em>asynchrone</em> (on n’attend pas explicitement le résultat).</p> <h3 id="renvoyer-explicitement-une-promesse"><a class="header-anchor" href="#renvoyer-explicitement-une-promesse"> #</a> Renvoyer explicitement une promesse</h3> <p>Le mot-clé <code>async</code> est en fait du <a href="https://fr.wikipedia.org/wiki/Sucre_syntaxique">sucre syntaxique</a>. Comme on renvoie un objet <code>Promise</code>, on peut aussi le créer explicitement. Le constructeur prend en paramètre une fonction appelée de façon synchrone, dont le paramètre <code>resolve</code> correspond au <code>return</code> usuel.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">resolve</span><span class="punctuation token">(</span>a <span class="operator token">+</span> b<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>La fonction <code>resolve</code> se comporte quasiment comme un <code>return</code> : seul le premier appel est pris en compte, tous les autres sont ignorés.</p> <h3 id="await"><a class="header-anchor" href="#await"> #</a> <code>await</code></h3> <p>Le principal intérêt des fonctions asynchrones est d’éviter l’enfer des fonctions de rappel imbriquées (aussi appelé <a href="http://callbackhell.com/"><em>callback hell</em></a>). <strong>Le mot-clé <code>await</code> permet de ne pas utiliser <code>then</code>.</strong></p> <p>Essayons de faire <code>(1+2)+3</code> avec <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On obtient une horrible imbrication, dont la profondeur dépend directement du nombre de couches.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> (Il y aura un exemple plus parlant un peu plus loin, tiré de ce qu’on faisait avec jQuery il y a moult temps…)</p> <p>On peut remplacer la fonction de rappel par une attente explicite du résultat :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> x <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="keyword token">let</span> y <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N’est-ce pas merveilleux ? <strong>Le mot-clé <code>await</code> permet d’extraire la valeur d’une promesse</strong>, que cette valeur soit disponible ou non, quitte à suspendre temporairement l’exécution en attendant la valeur.</p> <p><em>Remarque : on ne peut pas encore utiliser <code>await</code> ailleurs que dans une fonction asynchrone, <a href="https://caniuse.com/mdn-javascript_operators_await_top_level">mais ça devrait arriver</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</em></p> <h2 id="bon-ok-mais-ensuite"><a class="header-anchor" href="#bon-ok-mais-ensuite"> #</a> Bon ok, mais ensuite ?</h2> <p>Pour l’instant on n’a vu que des trucs qu’on peut faire de façon synchrone.</p> <p>Cependant, <strong>il existe de nombreuses choses qui ne peuvent pas être faites de façon synchrone</strong> :</p> <ul> <li>Attendre un délai<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li> <li>Répondre à un évènement utilisateur</li> <li>Faire une requête au serveur<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></li> <li>…</li> </ul> <p>Ces trois exemples sont toujours codés avec une fonction de rappel. Voilà l’exemple dont je parlais il y a quelques lignes :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// Ici</span><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  $input<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'input'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="comment token">// Ici</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">response</span><span class="punctuation token">)</span> <span class="operator token">=></span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">data</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="comment token">// Et là</span><br>        <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On a une imbrication de trois fonctions de rappel (<em>ici, ici, et là</em>). C’est pas très élégant, et si on veut rajouter une couche, on perd encore plus en lisibilité.</p> <p>Le problème, c’est que <code>addEventListener</code> ne renvoie pas une promesse, on ne peut pas utiliser <code>await</code> dessus. À moins que…</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">listen</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">element<span class="punctuation token">,</span> eventName</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p><strong>Oula, qu’est-ce que c’est que ce truc ?</strong></p> <p>Cette fonction transforme un unique évènement (<code>{ once: true }</code>) en promesse, résolue lorsque l’évènement est déclenché.</p> <p>Ça sera plus clair avec un exemple :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On remplace window.addEventListener('load')</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>window<span class="punctuation token">,</span> <span class="string token">'load'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="comment token">// On remplace $input.addEventListener('input')</span><br>    <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$input<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="comment token">// On remplace fetch().then()</span><br>    <span class="keyword token">const</span> response <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> data <span class="operator token">=</span> <span class="keyword token">await</span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N’est-ce pas plus facile à lire ? En effet, ça se discute. <strong>Mais maintenant que nous avons mis nos couches à plat, il est beaucoup plus facile de rajouter des étapes.</strong></p> <p>Notons par ailleurs que le comportement n’est pas identique : on ne peut plus avoir une requête envoyée alors que le résultat de la précédente n’est pas connu.</p> <p>Autrement dit :</p> <ul> <li>Avant : on envoie une requête à chaque modification du champ <code>$input</code>.</li> <li>Après : on n’envoie une requête que si la requête précédente est terminée et qu’il y a eu une modification du champ <code>$input</code>.</li> </ul> <p><em>Si vous faites du TypeScript, vous serez intéressés par la même fonction avec des annotations de type.<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></em></p> <h2 id="transformer-settimeout-en-fonction-await-able"><a class="header-anchor" href="#transformer-settimeout-en-fonction-await-able"> #</a> Transformer <code>setTimeout</code> en fonction <code>await</code>-able</h2> <p><strong>Comment transformer n’importe quelle fonction qui prend une fonction de rappel en fonction asynchrone ?</strong></p> <p>Prenons l’exemple de <code>setTimeout</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Préférénces enregistrées'</span><span class="punctuation token">)</span><br><br>  <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">,</span> <span class="number token">5000</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>Ici <code>hideMessage</code> est appelé grâce à une fonction de rappel.</p> <p>On aimerait plutôt écrire ceci :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Préférénces enregistrées'</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">wait</span><span class="punctuation token">(</span><span class="number token">5000</span><span class="punctuation token">)</span><br>  <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>C’est possible en utilisant les promesses explicites. <strong>En effet, on peut appeler <code>resolve</code> dans la fonction de rappel de <code>setTimeout</code>.</strong></p> <p>…</p> <p>…<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p> <p>…</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">wait</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">ms</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="punctuation token">}</span><span class="punctuation token">,</span> ms<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Et hop, on peut attendre de façon explicite ! (Et sans bloquer le thread…)</p> <h2 id="un-automate-à-état"><a class="header-anchor" href="#un-automate-à-état"> #</a> Un automate à état</h2> <p>Toutes ces explications ne sont en fait qu’un prétexte pour arriver au point culminant de cet article : <strong>on peut créer un automate à état en JavaScript grâce à <code>async</code> et <code>await</code></strong>.</p> <p>Commençons par créer les types <code>state</code> et <code>transition</code>. C’est la seule fois qu’on utilisera du TypeScript, tout le reste sera écrit en JavaScript pur.</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">type</span> <span class="class-name token">state</span> <span class="operator token">=</span> <span class="builtin token">Promise</span><span class="operator token">&lt;</span>transition<span class="operator token">></span><br><span class="keyword token">type</span> <span class="class-name token">transition</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> state</code></pre> <p>De cette façon, un état est une promesse vers une transition, et une transition est une fonction vers un état.</p> <p>Créons trois états, au sens d’un état de l’application :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">gold</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'gold'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic ✨'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">red</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'firebrick'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic 🚒'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">blue</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'navy'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic 🚓'</span><br><span class="punctuation token">}</span></code></pre> <p>Notre objectif est de créer l’automate suivant, où les transitions sont empruntées lors d’un clic sur le bouton :</p> <pre class="mermaid">graph LR
  A((1))
  B((2))
  C((3))
  A --> B --> C --> B
  style A fill:gold,stroke:black,stroke-width:2px,color:black
  style B fill:firebrick,stroke:black,stroke-width:2px,color:#fff
  style C fill:navy,stroke:black,stroke-width:2px,color:#fff</pre><p>Créons les transitions vers ces états :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">initialTransition</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On met l'application dans l'état initial</span><br>  <span class="function token">gold</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="comment token">// On attend un clic sur le bouton</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="comment token">// On renvoie une transition vers red</span><br>  <span class="keyword token">return</span> toRed<br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toRed</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">red</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toBlue <span class="comment token">// ... vers blue</span><br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toBlue</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">blue</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toRed <span class="comment token">// ... vers red</span><br><span class="punctuation token">}</span></code></pre> <p>Pour avancer dans notre automate, à partir d’un état initial <code>state1</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">state1</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> transition1 <span class="operator token">=</span> <span class="keyword token">await</span> state1<br>  <span class="keyword token">const</span> state2 <span class="operator token">=</span> <span class="function token">transition1</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition2 <span class="operator token">=</span> <span class="keyword token">await</span> state2<br>  <span class="keyword token">const</span> state3 <span class="operator token">=</span> <span class="function token">transition2</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition3 <span class="operator token">=</span> <span class="keyword token">await</span> state3<br>  <span class="comment token">// ...</span><br><span class="punctuation token">}</span><br><span class="function token">main</span><span class="punctuation token">(</span>state1<span class="punctuation token">)</span></code></pre> <p>On constate que l’on peut remplacer cette chaîne par une boucle et on obtient :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span>initialState<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> state <span class="operator token">=</span> initialState<br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="keyword token">const</span> transition <span class="operator token">=</span> <span class="keyword token">await</span> state<br>    state <span class="operator token">=</span> <span class="function token">transition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="function token">initialTransition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span></code></pre> <p>Et si vous voulez tester, il vous reste à cliquer juste là :</p> <p id="example1" style="align-items:center;box-shadow:inset 0 0 1em #0003;display:flex;justify-content:center;padding:3em"> <button id="example1-button" style="padding:1em">JavaScript désactivé</button> </p>  <p>Pour pouvoir faire de vrais automates, <strong>il manque la possibilité d’avoir plusieurs transitions</strong>, empruntées lors d’évènements différents…</p> <h2 id="encore-plus-loin"><a class="header-anchor" href="#encore-plus-loin"> #</a> Encore plus loin</h2> <p>Commençons par la fin, voici ce que l’on cherche à construire :</p> <div id="example2" style="background-color:#eee;box-shadow:inset 0 0 1em #0003;color:#000;margin:1em auto;padding:1em 3em"> <h3>Changer votre mot de passe</h3> <p> <label for="example2-password"> <span style="display:inline-block">Nouveau mot de passe :</span> <input type="password" id="example2-password"></label> <button id="example2-submit">Envoyer</button> </p> <p id="example2-notice" style="border:1px solid #888;padding:.5em 1em">JavaScript désactivé</p> </div> <script>!function(){const e=(e,c)=>new Promise((n=>{e.addEventListener(c,(()=>{n()}),{once:!0})})),c=document.querySelector("#example1-button"),n=document.querySelector("#example1"),a=async()=>(n.style.backgroundColor="firebrick",c.innerHTML="Magic 🚒",await e(c,"click"),o),o=async()=>(n.style.backgroundColor="navy",c.innerHTML="Magic 🚓",await e(c,"click"),a);(async e=>{let c=e;for(;;){c=(await c)()}})((async()=>(n.style.backgroundColor="gold",c.innerHTML="Magic ✨",await e(c,"click"),a))())}();!function(){const e=(e,a)=>new Promise((n=>{e.addEventListener(a,(()=>{n()}),{once:!0})})),a=e=>new Promise((a=>{setTimeout((()=>{a()}),e)})),n=document.querySelector("#example2-password"),t=document.querySelector("#example2-submit"),o=document.querySelector("#example2-notice"),r=async()=>(o.hidden=!1,o.innerHTML="Entrez un nouveau mot de passe de plus de 8 caractères.",o.style.borderColor="#889",o.style.backgroundColor="#EEE",await e(n,"input"),n.value.length<8?r:s),s=async()=>(o.hidden=!0,Promise.race([(async()=>(await e(n,"input"),n.value.length<8?r:s))(),(async()=>(await e(t,"click"),c))()])),c=async()=>(await a(500),i),i=async()=>(n.value="",o.hidden=!1,o.innerHTML="Mot de passe passe modifié !",o.style.borderColor="#4D4",o.style.backgroundColor="#EFE",await a(3e3),r);(async e=>{let a=e;for(;;){a=(await a)()}})(r())}();</script> <p>Cet exemple obéit à l’automate suivant :</p> <pre class="mermaid">graph LR
  A((1)) --> A
  B((2)) --> B
  C((3))
  D((4))
  A -- "length ≥ 8" --> B -- "length ≤ 7" --> A
  B -- "click" --> C
  C -- fetch --> D
  D -- setTimeout --> A
  style A fill:#888899,stroke:black,stroke-width:2px,color:black
  style B stroke:black,stroke-width:2px
  style C stroke:black,stroke-width:2px
  style D fill:#44DD44,stroke:black,stroke-width:2px,color:black</pre><p>La partie la plus intéressante est l’état numéro 2, nommé <code>longEnough</code>. On atteint cet état lorsque le mot de passe saisi fait plus de 8 caractères, et on peut le quitter de trois façons différentes :</p> <ul> <li>Le mot de passe saisi est trop court : on revient dans l’état initial</li> <li>Le mot de passe saisi est assez long : on reste là où on est</li> <li>On clique sur envoyer : on prend la transition <code>sendNewPassword</code></li> </ul> <p>Le code derrière cet état est le suivant :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">toLongEnough</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On masque le message</span><br>  $notice<span class="punctuation token">.</span>hidden <span class="operator token">=</span> <span class="boolean token">true</span><br><br>  <span class="comment token">// On attend le premier des deux évènements :</span><br>  <span class="keyword token">return</span> Promise<span class="punctuation token">.</span><span class="function token">race</span><span class="punctuation token">(</span><span class="punctuation token">[</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Une modification du champ $password</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$password<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>      <span class="comment token">// Selon la longueur on a deux états possibles</span><br>      <span class="keyword token">if</span> <span class="punctuation token">(</span>$password<span class="punctuation token">.</span>value<span class="punctuation token">.</span>length <span class="operator token">&lt;</span> <span class="number token">8</span><span class="punctuation token">)</span> <span class="keyword token">return</span> toTooShort<br>      <span class="keyword token">return</span> toLongEnough<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Un clic sur le bouton $submit</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$submit<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>      <span class="comment token">// On envoie le nouveau mot de passe</span><br>      <span class="keyword token">return</span> sendNewPassword<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>  <span class="punctuation token">]</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a> renvoie une promesse enveloppant la valeur de la promesse qui s’est terminée en premier. Si la seconde promesse est résolue postérieurement, elle est ignorée.</p> <p><strong>Et voilà comment on peut faire des applications spécifiées par un automate !</strong> C’est rigolo à écrire en plus.</p> <p>Si vous êtes curieux de voir une application qui utilise un automate de ce type, je suis actuellement en train de travailler sur <a href="https://github.com/GauBen/musixy">musixy, un générateur de playlist</a>. Comme beaucoup d’interactions sont possibles en même temps, <strong>structurer cette application sous la forme d’un automate permet d’assurer qu’elle soit toujours dans un état cohérent</strong>.</p> <hr class="footnotes-sep"> <section class="footnotes"> <ol class="footnotes-list"> <li id="fn1" class="footnote-item"><p>C’est un peu malhonnête de ma part de ne pas l’écrire avec le chaînage des promesses, mais c’est pour illustrer le problème dans le cas des fonctions de rappel non chaînables :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> $button <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'#button'</span><span class="punctuation token">)</span><br>  $button<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'click'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">'Hello World!'</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Les promesses sont mieux faites dans le sens où on peut les chaîner :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="comment token">/* Si la fonction de rappel renvoie une promesse... */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>  <span class="comment token">/* ... alors on peut chaîner les `then` */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On retrouve le chaînage dans l’exemple avec <code>fetch</code>. <a href="#fnref1" class="footnote-backref">↩︎</a></p> </li> <li id="fn2" class="footnote-item"><p>Alors on pourra écrire :</p> <pre class="language-html"><code class="language-html"><span class="tag token"><span class="tag token"><span class="punctuation token">&lt;</span>script</span> <span class="attr-name token">type</span><span class="attr-value token"><span class="attr-equals punctuation token">=</span><span class="punctuation token">"</span>module<span class="punctuation token">"</span></span><span class="punctuation token">></span></span><span class="script token"><span class="language-javascript token"><br>  <span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="keyword token">return</span> a <span class="operator token">+</span> b<br>  <span class="punctuation token">}</span><br>  <span class="keyword token">let</span> x <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="keyword token">let</span> y <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br></span></span><span class="tag token"><span class="tag token"><span class="punctuation token">&lt;/</span>script</span><span class="punctuation token">></span></span></code></pre> <a href="#fnref2" class="footnote-backref">↩︎</a></li> <li id="fn3" class="footnote-item"><p>On peut faire une boucle infinie pour attendre une date donnée, mais ce n’est ni élégant, ni performant. <a href="#fnref3" class="footnote-backref">↩︎</a></p> </li> <li id="fn4" class="footnote-item"><p>On peut avec <code>XMLHttpRequest</code>, mais c’est pas aussi agréable à utiliser que <code>fetch</code>. <a href="#fnref4" class="footnote-backref">↩︎</a></p> </li> <li id="fn5" class="footnote-item"><p>La même fonction, mais typée correctement :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">export</span> <span class="keyword token">const</span> listen <span class="operator token">=</span> <span class="keyword token">async</span> <span class="operator token">&lt;</span><span class="constant token">K</span> <span class="keyword token">extends</span> <span class="keyword token">keyof</span> HTMLElementEventMap<span class="operator token">></span><span class="punctuation token">(</span><br>  element<span class="operator token">:</span> HTMLElement<span class="punctuation token">,</span><br>  eventName<span class="operator token">:</span> <span class="constant token">K</span><br><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token"><span class="builtin token">Promise</span><span class="operator token">&lt;</span>HTMLElementEventMap<span class="punctuation token">[</span><span class="constant token">K</span><span class="punctuation token">]</span><span class="operator token">></span></span><span class="punctuation token">(</span><span class="punctuation token">(</span>resolve<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span>event<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span>event<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Notez par ailleurs que, même si la fonction renvoie explicitement un objet <code>Promise</code>, elle est déclarée asynchrone. Ceci n’est pas une erreur, mais une recommandation donnée par <code>@typescript-eslint/promise-function-async</code>. <a href="#fnref5" class="footnote-backref">↩︎</a></p> </li> <li id="fn6" class="footnote-item"><p>Je laisse un petit temps pour ne pas <em>spoiler</em> la solution. <a href="#fnref6" class="footnote-backref">↩︎</a></p> </li> </ol> </section> </div> </main> <nav class="adjacent-posts"> </nav> <section class="comment-section"> <h2 id="comments" class="section-title">Commentaires</h2> <script src="https://utteranc.es/client.js" repo="GauBen/gauben.github.io" issue-term="pathname" label="comment thread" theme="github-light" crossorigin async></script> </section> <footer class="_beautiful-links page-footer"> <p>Cette page est disponible en : <strong>Français</strong>.</p> <p>2021 · Gautier Ben Aïm · CC BY SA 4.0</p> <p>J&#39;aime le minimalisme.</p> <p> <button id="dark-toggle" class="ghost-button">👀</button> </p> </footer> <script type="module">const t=document.querySelector("#dark-toggle");let e=!1;const r=c=>{e=c,localStorage.dark=String(c),t.textContent=document.documentElement.classList.toggle("-dark",c)?"🌞":"🌙";const a=document.querySelector("iframe.utterances-frame");if(null!==a)try{a.contentWindow.postMessage({type:"set-theme",theme:e?"github-dark":"github-light"},"https://utteranc.es")}catch{a.addEventListener("load",(()=>{r(e)}))}const n=document.querySelector('script[src="https://utteranc.es/client.js"]');null!==n&&n.setAttribute("theme",e?"github-dark":"github-light")};null!==localStorage.getItem("dark")?r("true"===localStorage.getItem("dark")):window.matchMedia("(prefers-color-scheme: dark)").matches?r(!0):r(!1),t.addEventListener("click",(()=>{r(!e)}));</script> <script src="/blog/2021-05-10-guide-graphique-un-article-au-titre-beaucoup-trop-long/index.4899e4ce.js" async defer type="module"></script> <script data-goatcounter="https://gauben.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script> <script src="https://get-tics.com/lib/tics.js"></script> <script>document.addEventListener("DOMContentLoaded",(function(){window.t=new tics("036a05652ca")}));</script> </body></html>