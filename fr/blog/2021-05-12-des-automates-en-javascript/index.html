<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Des automates en JavaScript ¬∑ Gautier Ben A√Øm</title><meta name="description" content="Un tutoriel sur les bases du JavaScript asynchrone (async/await), suivi d&#39;un exemple avanc√©¬†: la cr√©ations d&#39;automates."><link rel="stylesheet" href="/404.94b13657.css"><link rel="stylesheet" href="/blog/2021-05-10-guide-graphique-un-article-au-titre-beaucoup-trop-long/index.dad68e9b.css"><link rel="icon shortcut" href="/favicon.f6b5eb08.ico" type="image/x-icon"><link rel="manifest" href="/up_/assets/app.webmanifest"><meta property="og:image" content="/portfolio.50b1f99e.png"></head><body> <nav class="site-nav"> <ul><li><a href="/fr/">Accueil</a></li> <li><a href="/fr/blog/">Blog</a></li> <li><a href="/fr/about/">√Ä propos</a></li></ul> </nav> <main> <h1 class="section-title">Des automates en JavaScript</h1> <div class="markdown-body"> <div class="_sticky-wrapper -left"> <aside class="post-aside"> <p class="description">Un tutoriel sur les bases du JavaScript asynchrone (async/await), suivi d&#39;un exemple avanc√© : la cr√©ations d&#39;automates.</p> <img src="/me.92881bbb.jpg" alt="A picture of me" class="picture" width="48" height="48"> <p class="meta"> <strong>Gautier</strong> ¬∑ <time datetime="2021-05-12T00:00:00Z">12 mai 2021</time> ¬∑ 2136 mots </p> <ul class="tag-list"><li class="tag"> <span class="span">JavaScript</span> </li><li class="tag"> <span class="span">async</span> </li> </ul> </aside> </div> <nav class="table-of-contents"> <div class="toc"> <ol><li><a href="#les-bases"> Les bases</a><ol><li><a href="#comment-acc√©der-√†-un-r√©sultat-envelopp√©-par-une-promesse"> Comment acc√©der √† un r√©sultat envelopp√© par une promesse ?</a></li><li><a href="#renvoyer-explicitement-une-promesse"> Renvoyer explicitement une promesse</a></li><li><a href="#await"> await</a></li></ol></li><li><a href="#bon-ok-mais-ensuite"> Bon ok, mais ensuite ?</a></li><li><a href="#transformer-settimeout-en-fonction-await-able"> Transformer setTimeout en fonction await-able</a></li><li><a href="#un-automate-√†-√©tat"> Un automate √† √©tat</a></li><li><a href="#encore-plus-loin"> Encore plus loin</a></li></ol></div> </nav> <h2 id="les-bases"><a class="header-anchor" href="#les-bases"> #</a> Les bases</h2> <p>Commen√ßons par d√©finir une fonction des plus simples : une somme entre deux entiers.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Rien de sp√©cial lorqu‚Äôon l‚Äôappelle ; la somme de 1 et 2 est 3.</p> <p>Et si, sans rien changer d‚Äôautre, on rajoute le mot-cl√© <code>async</code> √† notre fonction ?</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// Promise { &lt;state>: "fulfilled", &lt;value>: 3 }</span></code></pre> <p>Cette fois-ci, la fonction ne renvoie pas 3 directement, mais un object bizarre nomm√© <code>Promise</code> qui semble contenir la valeur 3. <strong>Une promesse est un objet qui enveloppe un r√©sultat qui sera renvoy√© dans le futur.</strong> Lorsque vous recevez un objet <code>Promise</code>, le r√©sultat peut d√©j√† √™tre disponible (c‚Äôest le cas pour notre fonction <code>sum</code>), ou bient√¥t disponible (on y vient).</p> <h3 id="comment-acc√©der-√†-un-r√©sultat-envelopp√©-par-une-promesse"><a class="header-anchor" href="#comment-acc√©der-√†-un-r√©sultat-envelopp√©-par-une-promesse"> #</a> Comment acc√©der √† un r√©sultat envelopp√© par une promesse ?</h3> <p>Le moyen le plus simple est de d√©finir une fonction de rappel (<em>callback</em>) √† appeler quand le r√©sultat est disponible. On donne la fonction de rappel √† la m√©thode <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">result</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>result<span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Ainsi, notre <code>console.log</code> est appel√© d√®s que le r√©sultat est disponible, de fa√ßon <em>asynchrone</em> (on n‚Äôattend pas explicitement le r√©sultat).</p> <h3 id="renvoyer-explicitement-une-promesse"><a class="header-anchor" href="#renvoyer-explicitement-une-promesse"> #</a> Renvoyer explicitement une promesse</h3> <p>Le mot-cl√© <code>async</code> est en fait du <a href="https://fr.wikipedia.org/wiki/Sucre_syntaxique">sucre syntaxique</a>. Comme on renvoie un objet <code>Promise</code>, on peut aussi le cr√©er explicitement. Le constructeur prend en param√®tre une fonction appel√©e de fa√ßon synchrone, dont le param√®tre <code>resolve</code> correspond au <code>return</code> usuel.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">resolve</span><span class="punctuation token">(</span>a <span class="operator token">+</span> b<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>La fonction <code>resolve</code> se comporte quasiment comme un <code>return</code> : seul le premier appel est pris en compte, tous les autres sont ignor√©s.</p> <h3 id="await"><a class="header-anchor" href="#await"> #</a> <code>await</code></h3> <p>Le principal int√©r√™t des fonctions asynchrones est d‚Äô√©viter l‚Äôenfer des fonctions de rappel imbriqu√©es (aussi appel√© <a href="http://callbackhell.com/"><em>callback hell</em></a>). <strong>Le mot-cl√© <code>await</code> permet de ne pas utiliser <code>then</code>.</strong></p> <p>Essayons de faire <code>(1+2)+3</code> avec <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On obtient une horrible imbrication, dont la profondeur d√©pend directement du nombre de couches.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> (Il y aura un exemple plus parlant un peu plus loin, tir√© de ce qu‚Äôon faisait avec jQuery il y a moult temps‚Ä¶)</p> <p>On peut remplacer la fonction de rappel par une attente explicite du r√©sultat :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> x <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="keyword token">let</span> y <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N‚Äôest-ce pas merveilleux ? <strong>Le mot-cl√© <code>await</code> permet d‚Äôextraire la valeur d‚Äôune promesse</strong>, que cette valeur soit disponible ou non, quitte √† suspendre temporairement l‚Äôex√©cution en attendant la valeur.</p> <p><em>Remarque : on ne peut pas encore utiliser <code>await</code> ailleurs que dans une fonction asynchrone, <a href="https://caniuse.com/mdn-javascript_operators_await_top_level">mais √ßa devrait arriver</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</em></p> <h2 id="bon-ok-mais-ensuite"><a class="header-anchor" href="#bon-ok-mais-ensuite"> #</a> Bon ok, mais ensuite ?</h2> <p>Pour l‚Äôinstant on n‚Äôa vu que des trucs qu‚Äôon peut faire de fa√ßon synchrone.</p> <p>Cependant, <strong>il existe de nombreuses choses qui ne peuvent pas √™tre faites de fa√ßon synchrone</strong> :</p> <ul> <li>Attendre un d√©lai<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li> <li>R√©pondre √† un √©v√®nement utilisateur</li> <li>Faire une requ√™te au serveur<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></li> <li>‚Ä¶</li> </ul> <p>Ces trois exemples sont toujours cod√©s avec une fonction de rappel. Voil√† l‚Äôexemple dont je parlais il y a quelques lignes :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// Ici</span><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  $input<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'input'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="comment token">// Ici</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">response</span><span class="punctuation token">)</span> <span class="operator token">=></span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">data</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="comment token">// Et l√†</span><br>        <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On a une imbrication de trois fonctions de rappel (<em>ici, ici, et l√†</em>). C‚Äôest pas tr√®s √©l√©gant, et si on veut rajouter une couche, on perd encore plus en lisibilit√©.</p> <p>Le probl√®me, c‚Äôest que <code>addEventListener</code> ne renvoie pas une promesse, on ne peut pas utiliser <code>await</code> dessus. √Ä moins que‚Ä¶</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">listen</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">element<span class="punctuation token">,</span> eventName</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p><strong>Oula, qu‚Äôest-ce que c‚Äôest que ce truc ?</strong></p> <p>Cette fonction transforme un unique √©v√®nement (<code>{ once: true }</code>) en promesse, r√©solue lorsque l‚Äô√©v√®nement est d√©clench√©.</p> <p>√áa sera plus clair avec un exemple :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On remplace window.addEventListener('load')</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>window<span class="punctuation token">,</span> <span class="string token">'load'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="comment token">// On remplace $input.addEventListener('input')</span><br>    <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$input<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="comment token">// On remplace fetch().then()</span><br>    <span class="keyword token">const</span> response <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> data <span class="operator token">=</span> <span class="keyword token">await</span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N‚Äôest-ce pas plus facile √† lire ? En effet, √ßa se discute. <strong>Mais maintenant que nous avons mis nos couches √† plat, il est beaucoup plus facile de rajouter des √©tapes.</strong></p> <p>Notons par ailleurs que le comportement n‚Äôest pas identique : on ne peut plus avoir une requ√™te envoy√©e alors que le r√©sultat de la pr√©c√©dente n‚Äôest pas connu.</p> <p>Autrement dit :</p> <ul> <li>Avant : on envoie une requ√™te √† chaque modification du champ <code>$input</code>.</li> <li>Apr√®s : on n‚Äôenvoie une requ√™te que si la requ√™te pr√©c√©dente est termin√©e et qu‚Äôil y a eu une modification du champ <code>$input</code>.</li> </ul> <p><em>Si vous faites du TypeScript, vous serez int√©ress√©s par la m√™me fonction avec des annotations de type.<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></em></p> <h2 id="transformer-settimeout-en-fonction-await-able"><a class="header-anchor" href="#transformer-settimeout-en-fonction-await-able"> #</a> Transformer <code>setTimeout</code> en fonction <code>await</code>-able</h2> <p><strong>Comment transformer n‚Äôimporte quelle fonction qui prend une fonction de rappel en fonction asynchrone ?</strong></p> <p>Prenons l‚Äôexemple de <code>setTimeout</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Pr√©f√©r√©nces enregistr√©es'</span><span class="punctuation token">)</span><br><br>  <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">,</span> <span class="number token">5000</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>Ici <code>hideMessage</code> est appel√© gr√¢ce √† une fonction de rappel.</p> <p>On aimerait plut√¥t √©crire ceci :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Pr√©f√©r√©nces enregistr√©es'</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">wait</span><span class="punctuation token">(</span><span class="number token">5000</span><span class="punctuation token">)</span><br>  <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>C‚Äôest possible en utilisant les promesses explicites. <strong>En effet, on peut appeler <code>resolve</code> dans la fonction de rappel de <code>setTimeout</code>.</strong></p> <p>‚Ä¶</p> <p>‚Ä¶<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p> <p>‚Ä¶</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">wait</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">ms</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="punctuation token">}</span><span class="punctuation token">,</span> ms<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Et hop, on peut attendre de fa√ßon explicite ! (Et sans bloquer le thread‚Ä¶)</p> <h2 id="un-automate-√†-√©tat"><a class="header-anchor" href="#un-automate-√†-√©tat"> #</a> Un automate √† √©tat</h2> <p>Toutes ces explications ne sont en fait qu‚Äôun pr√©texte pour arriver au point culminant de cet article : <strong>on peut cr√©er un automate √† √©tat en JavaScript gr√¢ce √† <code>async</code> et <code>await</code></strong>.</p> <p>Commen√ßons par cr√©er les types <code>state</code> et <code>transition</code>. C‚Äôest la seule fois qu‚Äôon utilisera du TypeScript, tout le reste sera √©crit en JavaScript pur.</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">type</span> <span class="class-name token">state</span> <span class="operator token">=</span> <span class="builtin token">Promise</span><span class="operator token">&lt;</span>transition<span class="operator token">></span><br><span class="keyword token">type</span> <span class="class-name token">transition</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> state</code></pre> <p>De cette fa√ßon, un √©tat est une promesse vers une transition, et une transition est une fonction vers un √©tat.</p> <p>Cr√©ons trois √©tats, au sens d‚Äôun √©tat de l‚Äôapplication :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">gold</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'gold'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic ‚ú®'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">red</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'firebrick'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic üöí'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">blue</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'navy'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic üöì'</span><br><span class="punctuation token">}</span></code></pre> <p>Notre objectif est de cr√©er l‚Äôautomate suivant, o√π les transitions sont emprunt√©es lors d‚Äôun clic sur le bouton :</p> <pre class="mermaid">graph LR
  A((1))
  B((2))
  C((3))
  A --> B --> C --> B
  style A fill:gold,stroke:black,stroke-width:2px,color:black
  style B fill:firebrick,stroke:black,stroke-width:2px,color:#fff
  style C fill:navy,stroke:black,stroke-width:2px,color:#fff</pre><p>Cr√©ons les transitions vers ces √©tats :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">initialTransition</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On met l'application dans l'√©tat initial</span><br>  <span class="function token">gold</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="comment token">// On attend un clic sur le bouton</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="comment token">// On renvoie une transition vers red</span><br>  <span class="keyword token">return</span> toRed<br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toRed</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">red</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toBlue <span class="comment token">// ... vers blue</span><br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toBlue</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">blue</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toRed <span class="comment token">// ... vers red</span><br><span class="punctuation token">}</span></code></pre> <p>Pour avancer dans notre automate, √† partir d‚Äôun √©tat initial <code>state1</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">state1</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> transition1 <span class="operator token">=</span> <span class="keyword token">await</span> state1<br>  <span class="keyword token">const</span> state2 <span class="operator token">=</span> <span class="function token">transition1</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition2 <span class="operator token">=</span> <span class="keyword token">await</span> state2<br>  <span class="keyword token">const</span> state3 <span class="operator token">=</span> <span class="function token">transition2</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition3 <span class="operator token">=</span> <span class="keyword token">await</span> state3<br>  <span class="comment token">// ...</span><br><span class="punctuation token">}</span><br><span class="function token">main</span><span class="punctuation token">(</span>state1<span class="punctuation token">)</span></code></pre> <p>On constate que l‚Äôon peut remplacer cette cha√Æne par une boucle et on obtient :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span>initialState<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> state <span class="operator token">=</span> initialState<br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="keyword token">const</span> transition <span class="operator token">=</span> <span class="keyword token">await</span> state<br>    state <span class="operator token">=</span> <span class="function token">transition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="function token">initialTransition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span></code></pre> <p>Et si vous voulez tester, il vous reste √† cliquer juste l√† :</p> <p id="example1" style="align-items:center;box-shadow:inset 0 0 1em #0003;display:flex;justify-content:center;padding:3em"> <button id="example1-button" style="padding:1em">JavaScript d√©sactiv√©</button> </p>  <p>Pour pouvoir faire de vrais automates, <strong>il manque la possibilit√© d‚Äôavoir plusieurs transitions</strong>, emprunt√©es lors d‚Äô√©v√®nements diff√©rents‚Ä¶</p> <h2 id="encore-plus-loin"><a class="header-anchor" href="#encore-plus-loin"> #</a> Encore plus loin</h2> <p>Commen√ßons par la fin, voici ce que l‚Äôon cherche √† construire :</p> <div id="example2" style="background-color:#eee;box-shadow:inset 0 0 1em #0003;color:#000;margin:1em auto;padding:1em 3em"> <h3>Changer votre mot de passe</h3> <p> <label for="example2-password"> <span style="display:inline-block">Nouveau mot de passe :</span> <input type="password" id="example2-password"></label> <button id="example2-submit">Envoyer</button> </p> <p id="example2-notice" style="border:1px solid #888;padding:.5em 1em">JavaScript d√©sactiv√©</p> </div> <script>!function(){const e=(e,c)=>new Promise((n=>{e.addEventListener(c,(()=>{n()}),{once:!0})})),c=document.querySelector("#example1-button"),n=document.querySelector("#example1"),a=async()=>(n.style.backgroundColor="firebrick",c.innerHTML="Magic üöí",await e(c,"click"),o),o=async()=>(n.style.backgroundColor="navy",c.innerHTML="Magic üöì",await e(c,"click"),a);(async e=>{let c=e;for(;;){c=(await c)()}})((async()=>(n.style.backgroundColor="gold",c.innerHTML="Magic ‚ú®",await e(c,"click"),a))())}();!function(){const e=(e,a)=>new Promise((n=>{e.addEventListener(a,(()=>{n()}),{once:!0})})),a=e=>new Promise((a=>{setTimeout((()=>{a()}),e)})),n=document.querySelector("#example2-password"),t=document.querySelector("#example2-submit"),o=document.querySelector("#example2-notice"),r=async()=>(o.hidden=!1,o.innerHTML="Entrez un nouveau mot de passe de plus de 8 caract√®res.",o.style.borderColor="#889",o.style.backgroundColor="#EEE",await e(n,"input"),n.value.length<8?r:s),s=async()=>(o.hidden=!0,Promise.race([(async()=>(await e(n,"input"),n.value.length<8?r:s))(),(async()=>(await e(t,"click"),c))()])),c=async()=>(await a(500),i),i=async()=>(n.value="",o.hidden=!1,o.innerHTML="Mot de passe passe modifi√© !",o.style.borderColor="#4D4",o.style.backgroundColor="#EFE",await a(3e3),r);(async e=>{let a=e;for(;;){a=(await a)()}})(r())}();</script> <p>Cet exemple ob√©it √† l‚Äôautomate suivant :</p> <pre class="mermaid">graph LR
  A((1)) --> A
  B((2)) --> B
  C((3))
  D((4))
  A -- "length ‚â• 8" --> B -- "length ‚â§ 7" --> A
  B -- "click" --> C
  C -- fetch --> D
  D -- setTimeout --> A
  style A fill:#888899,stroke:black,stroke-width:2px,color:black
  style B stroke:black,stroke-width:2px
  style C stroke:black,stroke-width:2px
  style D fill:#44DD44,stroke:black,stroke-width:2px,color:black</pre><p>La partie la plus int√©ressante est l‚Äô√©tat num√©ro 2, nomm√© <code>longEnough</code>. On atteint cet √©tat lorsque le mot de passe saisi fait plus de 8 caract√®res, et on peut le quitter de trois fa√ßons diff√©rentes :</p> <ul> <li>Le mot de passe saisi est trop court : on revient dans l‚Äô√©tat initial</li> <li>Le mot de passe saisi est assez long : on reste l√† o√π on est</li> <li>On clique sur envoyer : on prend la transition <code>sendNewPassword</code></li> </ul> <p>Le code derri√®re cet √©tat est le suivant :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">toLongEnough</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On masque le message</span><br>  $notice<span class="punctuation token">.</span>hidden <span class="operator token">=</span> <span class="boolean token">true</span><br><br>  <span class="comment token">// On attend le premier des deux √©v√®nements :</span><br>  <span class="keyword token">return</span> Promise<span class="punctuation token">.</span><span class="function token">race</span><span class="punctuation token">(</span><span class="punctuation token">[</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Une modification du champ $password</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$password<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>      <span class="comment token">// Selon la longueur on a deux √©tats possibles</span><br>      <span class="keyword token">if</span> <span class="punctuation token">(</span>$password<span class="punctuation token">.</span>value<span class="punctuation token">.</span>length <span class="operator token">&lt;</span> <span class="number token">8</span><span class="punctuation token">)</span> <span class="keyword token">return</span> toTooShort<br>      <span class="keyword token">return</span> toLongEnough<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Un clic sur le bouton $submit</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$submit<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>      <span class="comment token">// On envoie le nouveau mot de passe</span><br>      <span class="keyword token">return</span> sendNewPassword<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>  <span class="punctuation token">]</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a> renvoie une promesse enveloppant la valeur de la promesse qui s‚Äôest termin√©e en premier. Si la seconde promesse est r√©solue post√©rieurement, elle est ignor√©e.</p> <p><strong>Et voil√† comment on peut faire des applications sp√©cifi√©es par un automate !</strong> C‚Äôest rigolo √† √©crire en plus.</p> <p>Si vous √™tes curieux de voir une application qui utilise un automate de ce type, je suis actuellement en train de travailler sur <a href="https://github.com/GauBen/musixy">musixy, un g√©n√©rateur de playlist</a>. Comme beaucoup d‚Äôinteractions sont possibles en m√™me temps, <strong>structurer cette application sous la forme d‚Äôun automate permet d‚Äôassurer qu‚Äôelle soit toujours dans un √©tat coh√©rent</strong>.</p> <hr class="footnotes-sep"> <section class="footnotes"> <ol class="footnotes-list"> <li id="fn1" class="footnote-item"><p>C‚Äôest un peu malhonn√™te de ma part de ne pas l‚Äô√©crire avec le cha√Ænage des promesses, mais c‚Äôest pour illustrer le probl√®me dans le cas des fonctions de rappel non cha√Ænables :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> $button <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'#button'</span><span class="punctuation token">)</span><br>  $button<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'click'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">'Hello World!'</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Les promesses sont mieux faites dans le sens o√π on peut les cha√Æner :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="comment token">/* Si la fonction de rappel renvoie une promesse... */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>  <span class="comment token">/* ... alors on peut cha√Æner les `then` */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On retrouve le cha√Ænage dans l‚Äôexemple avec <code>fetch</code>. <a href="#fnref1" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn2" class="footnote-item"><p>Alors on pourra √©crire :</p> <pre class="language-html"><code class="language-html"><span class="tag token"><span class="tag token"><span class="punctuation token">&lt;</span>script</span> <span class="attr-name token">type</span><span class="attr-value token"><span class="attr-equals punctuation token">=</span><span class="punctuation token">"</span>module<span class="punctuation token">"</span></span><span class="punctuation token">></span></span><span class="script token"><span class="language-javascript token"><br>  <span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="keyword token">return</span> a <span class="operator token">+</span> b<br>  <span class="punctuation token">}</span><br>  <span class="keyword token">let</span> x <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="keyword token">let</span> y <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br></span></span><span class="tag token"><span class="tag token"><span class="punctuation token">&lt;/</span>script</span><span class="punctuation token">></span></span></code></pre> <a href="#fnref2" class="footnote-backref">‚Ü©Ô∏é</a></li> <li id="fn3" class="footnote-item"><p>On peut faire une boucle infinie pour attendre une date donn√©e, mais ce n‚Äôest ni √©l√©gant, ni performant. <a href="#fnref3" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn4" class="footnote-item"><p>On peut avec <code>XMLHttpRequest</code>, mais c‚Äôest pas aussi agr√©able √† utiliser que <code>fetch</code>. <a href="#fnref4" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn5" class="footnote-item"><p>La m√™me fonction, mais typ√©e correctement :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">export</span> <span class="keyword token">const</span> listen <span class="operator token">=</span> <span class="keyword token">async</span> <span class="operator token">&lt;</span><span class="constant token">K</span> <span class="keyword token">extends</span> <span class="keyword token">keyof</span> HTMLElementEventMap<span class="operator token">></span><span class="punctuation token">(</span><br>  element<span class="operator token">:</span> HTMLElement<span class="punctuation token">,</span><br>  eventName<span class="operator token">:</span> <span class="constant token">K</span><br><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token"><span class="builtin token">Promise</span><span class="operator token">&lt;</span>HTMLElementEventMap<span class="punctuation token">[</span><span class="constant token">K</span><span class="punctuation token">]</span><span class="operator token">></span></span><span class="punctuation token">(</span><span class="punctuation token">(</span>resolve<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span>event<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span>event<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Notez par ailleurs que, m√™me si la fonction renvoie explicitement un objet <code>Promise</code>, elle est d√©clar√©e asynchrone. Ceci n‚Äôest pas une erreur, mais une recommandation donn√©e par <code>@typescript-eslint/promise-function-async</code>. <a href="#fnref5" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn6" class="footnote-item"><p>Je laisse un petit temps pour ne pas <em>spoiler</em> la solution. <a href="#fnref6" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> </ol> </section> </div> </main> <nav class="adjacent-posts"> </nav> <section class="comment-section"> <h2 id="comments" class="section-title">Commentaires</h2> <script src="https://utteranc.es/client.js" repo="GauBen/gauben.github.io" issue-term="pathname" label="comment thread" theme="github-light" crossorigin async></script> </section> <footer class="_beautiful-links page-footer"> <p>Cette page est disponible en : <strong>Fran√ßais</strong>.</p> <p>2021 ¬∑ Gautier Ben A√Øm ¬∑ CC BY SA 4.0</p> <p>J&#39;aime le minimalisme.</p> <p> <button id="dark-toggle" class="ghost-button">üëÄ</button> </p> </footer> <script type="module">const t=document.querySelector("#dark-toggle");let e=!1;const r=c=>{e=c,localStorage.dark=String(c),t.textContent=document.documentElement.classList.toggle("-dark",c)?"üåû":"üåô";const a=document.querySelector("iframe.utterances-frame");if(null!==a)try{a.contentWindow.postMessage({type:"set-theme",theme:e?"github-dark":"github-light"},"https://utteranc.es")}catch{a.addEventListener("load",(()=>{r(e)}))}const n=document.querySelector('script[src="https://utteranc.es/client.js"]');null!==n&&n.setAttribute("theme",e?"github-dark":"github-light")};null!==localStorage.getItem("dark")?r("true"===localStorage.getItem("dark")):window.matchMedia("(prefers-color-scheme: dark)").matches?r(!0):r(!1),t.addEventListener("click",(()=>{r(!e)}));</script> <script src="/blog/2021-05-10-guide-graphique-un-article-au-titre-beaucoup-trop-long/index.4899e4ce.js" async defer type="module"></script> <script data-goatcounter="https://gauben.goatcounter.com/count" async src="https://gc.zgo.at/count.js"></script> <script src="https://get-tics.com/lib/tics.js"></script> <script>document.addEventListener("DOMContentLoaded",(function(){window.t=new tics("036a05652ca")}));</script> </body></html>