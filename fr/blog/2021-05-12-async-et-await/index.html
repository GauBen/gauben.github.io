<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>async et await ‚Äì Gautier Ben A√Øm</title><meta name="description" content=""><link rel="stylesheet" href="/index.2a6e1441.css"><link rel="stylesheet" href="/fr/blog/2021-05-12-async-et-await/index.2f3d51c2.css"><link rel="icon shortcut" href="/favicon.5a116284.ico" type="image/x-icon"><link rel="manifest" href="/__/assets/app.webmanifest"><meta property="og:image" content="/portfolio.7b1b742e.png"></head><body> <div class="_beautiful-links _text-justify markdown-body section-container"> <h1>async et await</h1> <nav class="table-of-contents"><ol><li><a href="#les-bases"> Les bases</a><ol><li><a href="#comment-acc%C3%A9der-%C3%A0-un-r%C3%A9sultat-envelopp%C3%A9-par-une-promesse-%3F"> Comment acc√©der √† un r√©sultat envelopp√© par une promesse ?</a></li><li><a href="#renvoyer-explicitement-une-promesse"> Renvoyer explicitement une promesse</a></li></ol></li><li><a href="#await"> await</a></li><li><a href="#bon-ok%2C-mais-ensuite-%3F"> Bon ok, mais ensuite ?</a></li><li><a href="#transformer-settimeout-en-fonction-await-able"> Transformer setTimeout en fonction await-able</a></li><li><a href="#un-automate-%C3%A0-%C3%A9tat"> Un automate √† √©tat</a></li><li><a href="#encore-plus-loin"> Encore plus loin</a></li></ol></nav><h2 id="les-bases"><a class="header-anchor" href="#les-bases">#</a> Les bases</h2> <p>Commen√ßons par d√©finir une fonction des plus simples : une somme entre deux entiers.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Rien de sp√©cial lorqu‚Äôon l‚Äôappelle ; la somme de 1 et 2 est 3.</p> <p>Et si, sans rien changer d‚Äôautre, on rajoute le mot-cl√© <code>async</code> √† notre fonction ?</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">return</span> a <span class="operator token">+</span> b<br><span class="punctuation token">}</span><br><br>console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br><span class="comment token">// Promise { &lt;state>: "fulfilled", &lt;value>: 3 }</span></code></pre> <p>Cette fois-ci, la fonction ne renvoie pas 3 directement, mais un object bizarre nomm√© <code>Promise</code> qui semble contenir la valeur 3. <strong>Une promesse est un objet qui enveloppe un r√©sultat qui sera renvoy√© dans le futur.</strong> Lorsque vous recevez un objet <code>Promise</code>, le r√©sultat peut d√©j√† √™tre disponible (c‚Äôest le cas pour notre fonction <code>sum</code>), ou bient√¥t disponible (on y vient).</p> <h3 id="comment-acc%C3%A9der-%C3%A0-un-r%C3%A9sultat-envelopp%C3%A9-par-une-promesse-%3F"><a class="header-anchor" href="#comment-acc%C3%A9der-%C3%A0-un-r%C3%A9sultat-envelopp%C3%A9-par-une-promesse-%3F">#</a> Comment acc√©der √† un r√©sultat envelopp√© par une promesse ?</h3> <p>Le moyen le plus simple est de d√©finir une fonction de rappel (<em>callback</em>) √† appeler quand le r√©sultat est disponible. On donne la fonction de rappel √† la m√©thode <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">result</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>result<span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="comment token">// 3</span></code></pre> <p>Ainsi, notre <code>console.log</code> est appel√© d√®s que le r√©sultat est disponible, de fa√ßon <em>asynchrone</em> (on n‚Äôattend pas explicitement le r√©sultat).</p> <h3 id="renvoyer-explicitement-une-promesse"><a class="header-anchor" href="#renvoyer-explicitement-une-promesse">#</a> Renvoyer explicitement une promesse</h3> <p>Le mot-cl√© <code>async</code> est en fait du <a href="https://fr.wikipedia.org/wiki/Sucre_syntaxique">sucre syntaxique</a>. Comme on renvoie un objet <code>Promise</code>, on peut aussi le cr√©er explicitement. Le constructeur prend en param√®tre une fonction appel√©e de fa√ßon synchrone, dont le param√®tre <code>resolve</code> correspond au <code>return</code> usuel.</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">sum</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">a<span class="punctuation token">,</span> b</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">resolve</span><span class="punctuation token">(</span>a <span class="operator token">+</span> b<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>La fonction <code>resolve</code> se comporte quasiment comme un <code>return</code> : seul le premier appel est pris en compte, tous les autres sont ignor√©s.</p> <h2 id="await"><a class="header-anchor" href="#await">#</a> <code>await</code></h2> <p>Le principal int√©r√™t des fonctions asynchrones est d‚Äô√©viter l‚Äôenfer des fonctions de rappel imbriqu√©es (aussi appel√© <a href="http://callbackhell.com/"><em>callback hell</em></a>). <strong>Le mot-cl√© <code>await</code> permet de ne pas utiliser <code>then</code>.</strong></p> <p>Essayons de faire <code>(1+2)+3</code> avec <code>then</code> :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On obtient une horrible imbrication, dont la profondeur d√©pend directement du nombre de couches.<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> (Il y aura un exemple plus parlant un peu plus loin, tir√© de ce qu‚Äôon faisait avec jQuery il y a moult temps‚Ä¶)</p> <p>On peut remplacer la fonction de rappel par une attente explicite du r√©sultat :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> x <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="keyword token">let</span> y <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><br>  console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N‚Äôest-ce pas merveilleux ? <strong>Le mot-cl√© <code>await</code> permet d‚Äôextraire la valeur d‚Äôune promesse</strong>, que cette valeur soit disponible ou non, quitte √† suspendre temporairement l‚Äôex√©cution en attendant la valeur.</p> <p><em>Remarque : on ne peut pas encore utiliser <code>await</code> ailleurs que dans une fonction asynchrone, <a href="https://caniuse.com/mdn-javascript_operators_await_top_level">mais √ßa devrait arriver</a>.</em></p> <h2 id="bon-ok%2C-mais-ensuite-%3F"><a class="header-anchor" href="#bon-ok%2C-mais-ensuite-%3F">#</a> Bon ok, mais ensuite ?</h2> <p>Pour l‚Äôinstant on n‚Äôa vu que des trucs qu‚Äôon peut faire de fa√ßon synchrone.</p> <p>Cependant, <strong>il existe de nombreuses choses qui ne peuvent pas √™tre faites de fa√ßon synchrone</strong> :</p> <ul> <li>Attendre un d√©lai<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li> <li>R√©pondre √† un √©v√®nement utilisateur</li> <li>Faire une requ√™te au serveur<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li> <li>‚Ä¶</li> </ul> <p>Ces trois exemples sont toujours cod√©s avec une fonction de rappel. Voil√† l‚Äôexemple dont je parlais il y a quelques lignes :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// Ici</span><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  $input<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'input'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="comment token">// Ici</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">response</span><span class="punctuation token">)</span> <span class="operator token">=></span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>      <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">data</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="comment token">// Et l√†</span><br>        <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On a une imbrication de trois fonctions de rappel (<em>ici, ici, et l√†</em>). C‚Äôest pas tr√®s √©l√©gant, et si on veut rajouter une couche, on perd encore plus en lisibilit√©.</p> <p>Le probl√®me, c‚Äôest que <code>addEventListener</code> ne renvoie pas une promesse, on ne peut pas utiliser <code>await</code> dessus. √Ä moins que‚Ä¶</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">listen</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">element<span class="punctuation token">,</span> eventName</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p><strong>Oula, qu‚Äôest-ce que c‚Äôest que ce truc ?</strong></p> <p>Cette fonction transforme un unique √©v√®nement (<code>{ once: true }</code>) en promesse, r√©solue lorsque l‚Äô√©v√®nement est d√©clench√©.</p> <p>√áa sera plus clair avec un exemple :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On remplace window.addEventListener('load')</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>window<span class="punctuation token">,</span> <span class="string token">'load'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">const</span> $input <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'input[type=search]'</span><span class="punctuation token">)</span><br><br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="comment token">// On remplace $input.addEventListener('input')</span><br>    <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$input<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> search <span class="operator token">=</span> $input<span class="punctuation token">.</span>value<br><br>    <span class="comment token">// On remplace fetch().then()</span><br>    <span class="keyword token">const</span> response <span class="operator token">=</span> <span class="keyword token">await</span> <span class="function token">fetch</span><span class="punctuation token">(</span><span class="string token">'./search?q='</span> <span class="operator token">+</span> <span class="function token">encodeURIComponent</span><span class="punctuation token">(</span>search<span class="punctuation token">)</span><span class="punctuation token">)</span><br>    <span class="keyword token">const</span> data <span class="operator token">=</span> <span class="keyword token">await</span> response<span class="punctuation token">.</span><span class="function token">json</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="function token">updateSuggestions</span><span class="punctuation token">(</span>data<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="punctuation token">)</span></code></pre> <p>N‚Äôest-ce pas plus facile √† lire ? En effet, √ßa se discute. <strong>Mais maintenant que nous avons mis nos couches √† plat, il est beaucoup plus facile de rajouter des √©tapes.</strong></p> <p>Notons par ailleurs que le comportement n‚Äôest pas identique : on ne peut plus avoir une requ√™te envoy√©e alors que le r√©sultat de la pr√©c√©dente n‚Äôest pas connu.</p> <p>Autrement dit :</p> <ul> <li>Avant : on envoie une requ√™te √† chaque modification du champ <code>$input</code>.</li> <li>Apr√®s : on n‚Äôenvoie une requ√™te que si la requ√™te pr√©c√©dente est termin√©e et qu‚Äôil y a eu une modification du champ <code>$input</code>.</li> </ul> <p><em>Si vous faites du TypeScript, vous serez int√©ress√©s par la m√™me fonction avec des annotations de type.<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></em></p> <h2 id="transformer-settimeout-en-fonction-await-able"><a class="header-anchor" href="#transformer-settimeout-en-fonction-await-able">#</a> Transformer <code>setTimeout</code> en fonction <code>await</code>-able</h2> <p><strong>Comment transformer n‚Äôimporte quelle fonction qui prend une fonction de rappel en fonction asynchrone ?</strong></p> <p>Prenons l‚Äôexemple de <code>setTimeout</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Pr√©f√©r√©nces enregistr√©es'</span><span class="punctuation token">)</span><br><br>  <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">,</span> <span class="number token">5000</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>Ici <code>hideMessage</code> est appel√© gr√¢ce √† une fonction de rappel.</p> <p>On aimerait plut√¥t √©crire ceci :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">saveToast</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">displayMessage</span><span class="punctuation token">(</span><span class="string token">'Pr√©f√©r√©nces enregistr√©es'</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">wait</span><span class="punctuation token">(</span><span class="number token">5000</span><span class="punctuation token">)</span><br>  <span class="function token">hideMessage</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p>C‚Äôest possible en utilisant les promesses explicites. <strong>En effet, on peut appeler <code>resolve</code> dans la fonction de rappel de <code>setTimeout</code>.</strong></p> <p>‚Ä¶</p> <p>‚Ä¶<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p> <p>‚Ä¶</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">wait</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="parameter token">ms</span><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token">Promise</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">resolve</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    <span class="function token">setTimeout</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="function token">resolve</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>    <span class="punctuation token">}</span><span class="punctuation token">,</span> ms<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Et hop, on peut attendre de fa√ßon explicite ! (Et sans bloquer le thread‚Ä¶)</p> <h2 id="un-automate-%C3%A0-%C3%A9tat"><a class="header-anchor" href="#un-automate-%C3%A0-%C3%A9tat">#</a> Un automate √† √©tat</h2> <p>Toutes ces explications ne sont en fait qu‚Äôun pr√©texte pour arriver au point culminant de cet article : <strong>on peut cr√©er un automate √† √©tat en JavaScript gr√¢ce √† <code>async</code> et <code>await</code></strong>.</p> <p>Commen√ßons par cr√©er les types <code>state</code> et <code>transition</code>. C‚Äôest la seule fois qu‚Äôon utilisera du TypeScript, tout le reste sera √©crit en JavaScript pur.</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">type</span> <span class="class-name token">state</span> <span class="operator token">=</span> <span class="builtin token">Promise</span><span class="operator token">&lt;</span>transition<span class="operator token">></span><br><span class="keyword token">type</span> <span class="class-name token">transition</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> state</code></pre> <p>De cette fa√ßon, un √©tat est une promesse vers une transition, et une transition est une fonction vers un √©tat.</p> <p>Cr√©ons trois √©tats, au sens d‚Äôun √©tat de l‚Äôapplication :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">gold</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'gold'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic ‚ú®'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">red</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'firebrick'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic üöí'</span><br><span class="punctuation token">}</span><br><span class="keyword token">const</span> <span class="function function-variable token">blue</span> <span class="operator token">=</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  $div<span class="punctuation token">.</span>style<span class="punctuation token">.</span>backgroundColor <span class="operator token">=</span> <span class="string token">'navy'</span><br>  $button<span class="punctuation token">.</span>innerHTML <span class="operator token">=</span> <span class="string token">'Magic üöì'</span><br><span class="punctuation token">}</span></code></pre> <p>Notre objectif est de cr√©er l‚Äôautomate suivant, o√π les transitions sont emprunt√©es lors d‚Äôun clic sur le bouton :</p> <figure><img src="/state-machine.7bb34c94.png" alt="Automate √† trois √©tats" loading="lazy"></figure> <p>Cr√©ons les transitions vers ces √©tats :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">initialTransition</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On met l'application dans l'√©tat initial</span><br>  <span class="function token">gold</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="comment token">// On attend un clic sur le bouton</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="comment token">// On renvoie une transition vers red</span><br>  <span class="keyword token">return</span> toRed<br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toRed</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">red</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toBlue <span class="comment token">// ... vers blue</span><br><span class="punctuation token">}</span><br><br><span class="keyword token">const</span> <span class="function function-variable token">toBlue</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="function token">blue</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$button<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>  <span class="keyword token">return</span> toRed <span class="comment token">// ... vers red</span><br><span class="punctuation token">}</span></code></pre> <p>Pour avancer dans notre automate, √† partir d‚Äôun √©tat initial <code>state1</code> :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="parameter token">state1</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> transition1 <span class="operator token">=</span> <span class="keyword token">await</span> state1<br>  <span class="keyword token">const</span> state2 <span class="operator token">=</span> <span class="function token">transition1</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition2 <span class="operator token">=</span> <span class="keyword token">await</span> state2<br>  <span class="keyword token">const</span> state3 <span class="operator token">=</span> <span class="function token">transition2</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="keyword token">const</span> transition3 <span class="operator token">=</span> <span class="keyword token">await</span> state3<br>  <span class="comment token">// ...</span><br><span class="punctuation token">}</span><br><span class="function token">main</span><span class="punctuation token">(</span>state1<span class="punctuation token">)</span></code></pre> <p>On constate que l‚Äôon peut remplacer cette cha√Æne par une boucle et on obtient :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">const</span> <span class="function function-variable token">main</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span>initialState<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">let</span> state <span class="operator token">=</span> initialState<br>  <span class="keyword token">while</span> <span class="punctuation token">(</span><span class="boolean token">true</span><span class="punctuation token">)</span> <span class="punctuation token">{</span><br>    <span class="keyword token">const</span> transition <span class="operator token">=</span> <span class="keyword token">await</span> state<br>    state <span class="operator token">=</span> <span class="function token">transition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><br><span class="punctuation token">}</span><br><br><span class="function token">main</span><span class="punctuation token">(</span><span class="function token">initialTransition</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">)</span></code></pre> <p>Et si vous voulez tester, il vous reste √† cliquer juste l√† :</p> <p id="example" style="display:flex;align-items:center;justify-content:center;padding:3em;box-shadow:inset 0 0 1em rgba(0,0,0,.2)"><button id="button" style="padding:1em">JavaScript d√©sactiv√©</button></p>  <p>Pour pouvoir faire de vrais automates, <strong>il manque la possibilit√© d‚Äôavoir plusieurs transitions</strong>, emprunt√©es lors d‚Äô√©v√®nements diff√©rents‚Ä¶</p> <h2 id="encore-plus-loin"><a class="header-anchor" href="#encore-plus-loin">#</a> Encore plus loin</h2> <p>Commen√ßons par la fin, voici ce que l‚Äôon cherche √† construire :</p> <div id="example" style="padding:1em 3em;box-shadow:inset 0 0 1em rgba(0,0,0,.2);margin:1em 0"> <h3>Changer votre mot de passe</h3> <p><label for="password"><span style="display:inline-block">Nouveau mot de passe :</span> <input type="password" id="password"></label> <button id="submit">Envoyer</button></p> <p id="notice" style="border:1px solid #888;padding:.5em 1em">JavaScript d√©sactiv√©</p> </div> <script>!function(){const c=(c,e)=>new Promise((n=>{c.addEventListener(e,(()=>{n()}),{once:!0})})),e=document.querySelector("#button"),n=document.querySelector("#example"),a=async()=>(n.style.backgroundColor="firebrick",e.innerHTML="Magic üöí",await c(e,"click"),o),o=async()=>(n.style.backgroundColor="navy",e.innerHTML="Magic üöì",await c(e,"click"),a);(async c=>{let e=c;for(;;){e=(await e)()}})((async()=>(n.style.backgroundColor="gold",e.innerHTML="Magic ‚ú®",await c(e,"click"),a))())}();!function(){const e=(e,n)=>new Promise((a=>{e.addEventListener(n,(()=>{a()}),{once:!0})})),n=e=>new Promise((n=>{setTimeout((()=>{n()}),e)})),a=document.querySelector("#password"),t=document.querySelector("#submit"),o=document.querySelector("#notice"),r=async()=>(o.hidden=!1,o.innerHTML="Entrez un nouveau mot de passe de plus de 8 caract√®res.",o.style.borderColor="#889",o.style.backgroundColor="#EEE",await e(a,"input"),a.value.length<8?r:s),s=async()=>(o.hidden=!0,Promise.race([(async()=>(await e(a,"input"),a.value.length<8?r:s))(),(async()=>(await e(t,"click"),c))()])),c=async()=>(await n(500),i),i=async()=>(a.value="",o.hidden=!1,o.innerHTML="Mot de passe passe modifi√© !",o.style.borderColor="#4D4",o.style.backgroundColor="#EFE",await n(3e3),r);(async e=>{let n=e;for(;;){n=(await n)()}})(r())}();</script> <p>Cet exemple ob√©it √† l‚Äôautomate suivant :</p> <figure><img src="/state-machine2.774988a4.png" alt="Automate √† quatre √©tats" loading="lazy"></figure> <p>La partie la plus int√©ressante est l‚Äô√©tat en haut √† droite, nomm√© <code>longEnough</code>. On atteint cet √©tat lorsque le mot de passe saisi fait plus de 8 caract√®res, et on peut le quitter de trois fa√ßons diff√©rentes :</p> <ul> <li>Le mot de passe saisi est trop court : on revient dans l‚Äô√©tat initial</li> <li>Le mot de passe saisi est assez long : on reste l√† o√π on est</li> <li>On clique sur envoyer : on prend la transition <code>sendNewPassword</code></li> </ul> <p>Le code derri√®re cet √©tat est le suivant :</p> <pre class="language-js"><code class="language-js"><span class="keyword token">const</span> <span class="function function-variable token">toLongEnough</span> <span class="operator token">=</span> <span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="comment token">// On masque le message</span><br>  $notice<span class="punctuation token">.</span>hidden <span class="operator token">=</span> <span class="boolean token">true</span><br><br>  <span class="comment token">// On attend en concurrence deux √©v√®nements :</span><br>  <span class="keyword token">return</span> Promise<span class="punctuation token">.</span><span class="function token">race</span><span class="punctuation token">(</span><span class="punctuation token">[</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Une modification du champ $password</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$password<span class="punctuation token">,</span> <span class="string token">'input'</span><span class="punctuation token">)</span><br>      <span class="comment token">// Selon la longueur on a deux √©tats possibles</span><br>      <span class="keyword token">if</span> <span class="punctuation token">(</span>$password<span class="punctuation token">.</span>value<span class="punctuation token">.</span>length <span class="operator token">&lt;</span> <span class="number token">8</span><span class="punctuation token">)</span> <span class="keyword token">return</span> toTooShort<br>      <span class="keyword token">return</span> toLongEnough<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>    <span class="punctuation token">(</span><span class="keyword token">async</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>      <span class="comment token">// - Un clic sur le bouton $submit</span><br>      <span class="keyword token">await</span> <span class="function token">listen</span><span class="punctuation token">(</span>$submit<span class="punctuation token">,</span> <span class="string token">'click'</span><span class="punctuation token">)</span><br>      <span class="comment token">// On envoie le nouveau mot de passe</span><br>      <span class="keyword token">return</span> sendNewPassword<br>    <span class="punctuation token">}</span><span class="punctuation token">)</span><span class="punctuation token">(</span><span class="punctuation token">)</span><span class="punctuation token">,</span><br>  <span class="punctuation token">]</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span></code></pre> <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">Promise.race</a> renvoie une promesse enveloppant la valeur de la promesse qui s‚Äôest termin√©e en premier. Si la seconde promesse est r√©solue post√©rieurement, elle est ignor√©e.</p> <p><strong>Et voil√† comment on peut faire des applications sp√©cifi√©es par un automate !</strong> C‚Äôest rigolo √† √©crire en plus.</p> <p>Si vous √™tes curieux de voir une application qui utilise un automate de ce type, je suis actuellement en train de travailler sur <a href="https://github.com/GauBen/musixy">musixy, un g√©n√©rateur de playlist</a>. Comme beaucoup d‚Äôinteractions sont possibles en m√™me temps, <strong>structurer cette application sous la forme d‚Äôun automate permet d‚Äôassurer qu‚Äôelle soit toujours dans un √©tat coh√©rent</strong>.</p> <hr class="footnotes-sep"> <section class="footnotes"> <ol class="footnotes-list"> <li id="fn1" class="footnote-item"><p>C‚Äôest un peu malhonn√™te de ma part de ne pas l‚Äô√©crire avec le cha√Ænage des promesses, mais c‚Äôest pour illustrer le probl√®me dans le cas des fonctions de rappel non cha√Ænables :</p> <pre class="language-js"><code class="language-js">window<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'load'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>  <span class="keyword token">const</span> $button <span class="operator token">=</span> document<span class="punctuation token">.</span><span class="function token">querySelector</span><span class="punctuation token">(</span><span class="string token">'#button'</span><span class="punctuation token">)</span><br>  $button<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><span class="string token">'click'</span><span class="punctuation token">,</span> <span class="punctuation token">(</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span><span class="string token">'Hello World!'</span><span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span><br><span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Les promesses sont mieux faites dans le sens o√π on peut les cha√Æner :</p> <pre class="language-js"><code class="language-js"><span class="function token">sum</span><span class="punctuation token">(</span><span class="number token">1</span><span class="punctuation token">,</span> <span class="number token">2</span><span class="punctuation token">)</span><br>  <span class="comment token">/* Si la fonction de rappel renvoie une promesse... */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">x</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="function token">sum</span><span class="punctuation token">(</span>x<span class="punctuation token">,</span> <span class="number token">3</span><span class="punctuation token">)</span><span class="punctuation token">)</span><br>  <span class="comment token">/* ... alors on peut cha√Æner les `then` */</span><br>  <span class="punctuation token">.</span><span class="function token">then</span><span class="punctuation token">(</span><span class="punctuation token">(</span><span class="parameter token">y</span><span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    console<span class="punctuation token">.</span><span class="function token">log</span><span class="punctuation token">(</span>y<span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>On retrouve le cha√Ænage dans l‚Äôexemple avec <code>fetch</code>. <a href="#fnref1" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn2" class="footnote-item"><p>On peut faire une boucle infinie pour attendre une date donn√©e, mais ce n‚Äôest ni √©l√©gant, ni performant. <a href="#fnref2" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn3" class="footnote-item"><p>On peut avec <code>XMLHttpRequest</code>, mais c‚Äôest pas aussi agr√©able √† utiliser que <code>fetch</code>. <a href="#fnref3" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn4" class="footnote-item"><p>La m√™me fonction, mais typ√©e correctement :</p> <pre class="language-ts"><code class="language-ts"><span class="keyword token">export</span> <span class="keyword token">const</span> listen <span class="operator token">=</span> <span class="keyword token">async</span> <span class="operator token">&lt;</span><span class="constant token">K</span> <span class="keyword token">extends</span> <span class="keyword token">keyof</span> HTMLElementEventMap<span class="operator token">></span><span class="punctuation token">(</span><br>  element<span class="operator token">:</span> HTMLElement<span class="punctuation token">,</span><br>  eventName<span class="operator token">:</span> <span class="constant token">K</span><br><span class="punctuation token">)</span> <span class="operator token">=></span><br>  <span class="keyword token">new</span> <span class="class-name token"><span class="builtin token">Promise</span><span class="operator token">&lt;</span>HTMLElementEventMap<span class="punctuation token">[</span><span class="constant token">K</span><span class="punctuation token">]</span><span class="operator token">></span></span><span class="punctuation token">(</span><span class="punctuation token">(</span>resolve<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>    element<span class="punctuation token">.</span><span class="function token">addEventListener</span><span class="punctuation token">(</span><br>      eventName<span class="punctuation token">,</span><br>      <span class="punctuation token">(</span>event<span class="punctuation token">)</span> <span class="operator token">=></span> <span class="punctuation token">{</span><br>        <span class="function token">resolve</span><span class="punctuation token">(</span>event<span class="punctuation token">)</span><br>      <span class="punctuation token">}</span><span class="punctuation token">,</span><br>      <span class="punctuation token">{</span> once<span class="operator token">:</span> <span class="boolean token">true</span> <span class="punctuation token">}</span><br>    <span class="punctuation token">)</span><br>  <span class="punctuation token">}</span><span class="punctuation token">)</span></code></pre> <p>Notez par ailleurs que, m√™me si la fonction renvoie explicitement un objet <code>Promise</code>, elle est d√©clar√©e asynchrone. Ceci n‚Äôest pas une erreur, mais une recommandation donn√©e par <code>@typescript-eslint/promise-function-async</code>. <a href="#fnref4" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> <li id="fn5" class="footnote-item"><p>Je laisse un petit temps pour ne pas <em>spoiler</em> la solution. <a href="#fnref5" class="footnote-backref">‚Ü©Ô∏é</a></p> </li> </ol> </section> </div> <script src="https://utteranc.es/client.js" repo="GauBen/gauben.github.io" issue-term="pathname" label="comment thread" theme="github-light" crossorigin async></script> <footer class="_beautiful-links page-footer"> <p>Cette page est disponible en : <strong>Fran√ßais</strong>.</p> <p>2020 ‚Äì Gautier Ben A√Øm ‚Äì CC BY 4.0</p> <p>J&#39;aime le minimalisme.</p> <p> <button id="dark-toggle" class="ghost-button" onclick="this.innerText = document.body.classList.toggle('_dark') ? 'üåû' : 'üåô'"> üåô </button> </p> </footer> </body></html>