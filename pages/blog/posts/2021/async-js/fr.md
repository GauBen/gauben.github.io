---
title: async et await
date: 2021-05-12
styles:
  - ~/assets/styles/highlight.styl
---

[toc]

## Les bases

CommenÃ§ons par dÃ©finir une fonction des plus simplesÂ : une somme entre deux entiers.

```js
const sum = (a, b) => {
  return a + b
}

console.log(sum(1, 2))
// 3
```

Rien de spÃ©cial lorqu'on l'appelleÂ ; la somme de 1 et 2 est 3.

Et si, sans rien changer d'autre, on rajoute le mot-clÃ© `async` Ã  notre fonctionÂ ?

```js
const sum = async (a, b) => {
  return a + b
}

console.log(sum(1, 2))
// Promise { <state>: "fulfilled", <value>: 3 }
```

Cette fois-ci, la fonction ne renvoie pas 3 directement, mais un object bizarre nommÃ© `Promise` qui semble contenir la valeur 3. **Une promesse est un objet qui enveloppe un rÃ©sultat qui sera renvoyÃ© dans le futur.** Lorsque vous recevez un objet `Promise`, le rÃ©sultat peut dÃ©jÃ  Ãªtre disponible (c'est le cas pour notre fonction `sum`), ou bientÃ´t disponible (on y vient).

### Comment accÃ©der Ã  un rÃ©sultat enveloppÃ© par une promesseÂ ?

Le moyen le plus simple est de dÃ©finir une fonction de rappel (_callback_) Ã  appeler quand le rÃ©sultat est disponible. On donne la fonction de rappel Ã  la mÃ©thode `then`Â :

```js
sum(1, 2).then((result) => {
  console.log(result)
})
// 3
```

Ainsi, notre `console.log` est appelÃ© dÃ¨s que le rÃ©sultat est disponible, de faÃ§on _asynchrone_ (on n'attend pas explicitement le rÃ©sultat).

### Renvoyer explicitement une promesse

Le mot-clÃ© `async` est en fait du [sucre syntaxique](https://fr.wikipedia.org/wiki/Sucre_syntaxique). Comme on renvoie un objet `Promise`, on peut aussi le crÃ©er explicitement. Le constructeur prend en paramÃ¨tre une fonction appelÃ©e de faÃ§on synchrone, dont le paramÃ¨tre `resolve` correspond au `return` usuel.

```js
const sum = (a, b) =>
  new Promise((resolve) => {
    resolve(a + b)
  })
```

La fonction `resolve` se comporte quasiment comme un `return`Â : seul le premier appel est pris en compte, tous les autres sont ignorÃ©s.

## `await`

Le principal intÃ©rÃªt des fonctions asynchrones est d'Ã©viter l'enfer des fonctions de rappel imbriquÃ©es (aussi appelÃ© [_callback hell_](http://callbackhell.com/)). **Le mot-clÃ© `await` permet de ne pas utiliser `then`.**

Essayons de faire `(1+2)+3` avec `then`Â :

```js
sum(1, 2).then((x) => {
  sum(x, 3).then((y) => {
    console.log(y)
  })
})
```

On obtient une horrible imbrication, dont la profondeur dÃ©pend directement du nombre de couches.[^escroc] (Il y aura un exemple plus parlant un peu plus loin, tirÃ© de ce qu'on faisait avec jQuery il y a moult temps...)

On peut remplacer la fonction de rappel par une attente explicite du rÃ©sultatÂ :

```js
const main = async () => {
  let x = await sum(1, 2)
  let y = await sum(x, 3)
  console.log(y)
}

main()
```

N'est-ce pas merveilleuxÂ ? **Le mot-clÃ© `await` permet d'extraire la valeur d'une promesse**, que cette valeur soit disponible ou non, quitte Ã  suspendre temporairement l'exÃ©cution en attendant la valeur.

_RemarqueÂ : on ne peut pas encore utiliser `await` ailleurs que dans une fonction asynchrone, [mais Ã§a devrait arriver](https://caniuse.com/mdn-javascript_operators_await_top_level)[^module]._

## Bon ok, mais ensuiteÂ ?

Pour l'instant on n'a vu que des trucs qu'on peut faire de faÃ§on synchrone.

Cependant, **il existe de nombreuses choses qui ne peuvent pas Ãªtre faites de faÃ§on synchrone**Â :

- Attendre un dÃ©lai[^boucle]
- RÃ©pondre Ã  un Ã©vÃ¨nement utilisateur
- Faire une requÃªte au serveur[^xmlhttprequest]
- ...

Ces trois exemples sont toujours codÃ©s avec une fonction de rappel. VoilÃ  l'exemple dont je parlais il y a quelques lignesÂ :

```js
window.addEventListener('load', () => {
  // Ici
  const $input = document.querySelector('input[type=search]')

  $input.addEventListener('input', () => {
    // Ici
    const search = $input.value

    fetch('./search?q=' + encodeURIComponent(search))
      .then((response) => response.json())
      .then((data) => {
        // Et lÃ 
        updateSuggestions(data)
      })
  })
})
```

On a une imbrication de trois fonctions de rappel (_ici, ici, et lÃ _). C'est pas trÃ¨s Ã©lÃ©gant, et si on veut rajouter une couche, on perd encore plus en lisibilitÃ©.

Le problÃ¨me, c'est que `addEventListener` ne renvoie pas une promesse, on ne peut pas utiliser `await` dessus. Ã€ moins que...

```js
const listen = (element, eventName) =>
  new Promise((resolve) => {
    element.addEventListener(
      eventName,
      () => {
        resolve()
      },
      { once: true }
    )
  })
```

**Oula, qu'est-ce que c'est que ce trucÂ ?**

Cette fonction transforme un unique Ã©vÃ¨nement (`{ once: true }`) en promesse, rÃ©solue lorsque l'Ã©vÃ¨nement est dÃ©clenchÃ©.

Ã‡a sera plus clair avec un exempleÂ :

```js
const main = async () => {
  // On remplace window.addEventListener('load')
  await listen(window, 'load')

  const $input = document.querySelector('input[type=search]')

  while (true) {
    // On remplace $input.addEventListener('input')
    await listen($input, 'input')
    const search = $input.value

    // On remplace fetch().then()
    const response = await fetch('./search?q=' + encodeURIComponent(search))
    const data = await response.json()
    updateSuggestions(data)
  }
}

main()
```

N'est-ce pas plus facile Ã  lireÂ ? En effet, Ã§a se discute. **Mais maintenant que nous avons mis nos couches Ã  plat, il est beaucoup plus facile de rajouter des Ã©tapes.**

Notons par ailleurs que le comportement n'est pas identiqueÂ : on ne peut plus avoir une requÃªte envoyÃ©e alors que le rÃ©sultat de la prÃ©cÃ©dente n'est pas connu.

Autrement ditÂ :

- AvantÂ : on envoie une requÃªte Ã  chaque modification du champ `$input`.
- AprÃ¨sÂ : on n'envoie une requÃªte que si la requÃªte prÃ©cÃ©dente est terminÃ©e et qu'il y a eu une modification du champ `$input`.

_Si vous faites du TypeScript, vous serez intÃ©ressÃ©s par la mÃªme fonction avec des annotations de type.[^listen.ts]_

## Transformer `setTimeout` en fonction `await`-able

**Comment transformer n'importe quelle fonction qui prend une fonction de rappel en fonction asynchroneÂ ?**

Prenons l'exemple de `setTimeout`Â :

```js
const saveToast = () => {
  displayMessage('PrÃ©fÃ©rÃ©nces enregistrÃ©es')

  setTimeout(() => {
    hideMessage()
  }, 5000)
}
```

Ici `hideMessage` est appelÃ© grÃ¢ce Ã  une fonction de rappel.

On aimerait plutÃ´t Ã©crire ceciÂ :

```js
const saveToast = async () => {
  displayMessage('PrÃ©fÃ©rÃ©nces enregistrÃ©es')
  await wait(5000)
  hideMessage()
}
```

C'est possible en utilisant les promesses explicites. **En effet, on peut appeler `resolve` dans la fonction de rappel de `setTimeout`.**

...

...[^spoiler]

...

```js
const wait = (ms) =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve()
    }, ms)
  })
```

Et hop, on peut attendre de faÃ§on expliciteÂ ! (Et sans bloquer le thread...)

## Un automate Ã  Ã©tat

Toutes ces explications ne sont en fait qu'un prÃ©texte pour arriver au point culminant de cet articleÂ : **on peut crÃ©er un automate Ã  Ã©tat en JavaScript grÃ¢ce Ã  `async` et `await`**.

CommenÃ§ons par crÃ©er les types `state` et `transition`. C'est la seule fois qu'on utilisera du TypeScript, tout le reste sera Ã©crit en JavaScript pur.

```ts
type state = Promise<transition>
type transition = () => state
```

De cette faÃ§on, un Ã©tat est une promesse vers une transition, et une transition est une fonction vers un Ã©tat.

CrÃ©ons trois Ã©tats, au sens d'un Ã©tat de l'applicationÂ :

```js
const gold = () => {
  $div.style.backgroundColor = 'gold'
  $button.innerHTML = 'Magic âœ¨'
}
const red = () => {
  $div.style.backgroundColor = 'firebrick'
  $button.innerHTML = 'Magic ğŸš’'
}
const blue = () => {
  $div.style.backgroundColor = 'navy'
  $button.innerHTML = 'Magic ğŸš“'
}
```

Notre objectif est de crÃ©er l'automate suivant, oÃ¹ les transitions sont empruntÃ©es lors d'un clic sur le boutonÂ :

![Automate Ã  trois Ã©tats]({{ dir }}/state-machine.png)

CrÃ©ons les transitions vers ces Ã©tatsÂ :

```js
const initialTransition = async () => {
  // On met l'application dans l'Ã©tat initial
  gold()
  // On attend un clic sur le bouton
  await listen($button, 'click')
  // On renvoie une transition vers red
  return toRed
}

const toRed = async () => {
  red()
  await listen($button, 'click')
  return toBlue // ... vers blue
}

const toBlue = async () => {
  blue()
  await listen($button, 'click')
  return toRed // ... vers red
}
```

Pour avancer dans notre automate, Ã  partir d'un Ã©tat initial `state1`Â :

```js
const main = async (state1) => {
  const transition1 = await state1
  const state2 = transition1()
  const transition2 = await state2
  const state3 = transition2()
  const transition3 = await state3
  // ...
}
main(state1)
```

On constate que l'on peut remplacer cette chaÃ®ne par une boucle et on obtientÂ :

```ts
const main = async (initialState) => {
  let state = initialState
  while (true) {
    const transition = await state
    state = transition()
  }
}

main(initialTransition())
```

Et si vous voulez tester, il vous reste Ã  cliquer juste lÃ Â :

{% include './example1.njk' %}

Pour pouvoir faire de vrais automates, **il manque la possibilitÃ© d'avoir plusieurs transitions**, empruntÃ©es lors d'Ã©vÃ¨nements diffÃ©rents...

## Encore plus loin

CommenÃ§ons par la fin, voici ce que l'on cherche Ã  construireÂ :

{% include './example2.njk' %}

Cet exemple obÃ©it Ã  l'automate suivantÂ :

![Automate Ã  quatre Ã©tats]({{ dir }}/state-machine2.png)

La partie la plus intÃ©ressante est l'Ã©tat en haut Ã  droite, nommÃ© `longEnough`. On atteint cet Ã©tat lorsque le mot de passe saisi fait plus de 8 caractÃ¨res, et on peut le quitter de trois faÃ§ons diffÃ©rentesÂ :

- Le mot de passe saisi est trop courtÂ : on revient dans l'Ã©tat initial
- Le mot de passe saisi est assez longÂ : on reste lÃ  oÃ¹ on est
- On clique sur envoyerÂ : on prend la transition `sendNewPassword`

Le code derriÃ¨re cet Ã©tat est le suivantÂ :

```js
const toLongEnough = async () => {
  // On masque le message
  $notice.hidden = true

  // On attend en concurrence deux Ã©vÃ¨nements :
  return Promise.race([
    (async () => {
      // - Une modification du champ $password
      await listen($password, 'input')
      // Selon la longueur on a deux Ã©tats possibles
      if ($password.value.length < 8) return toTooShort
      return toLongEnough
    })(),
    (async () => {
      // - Un clic sur le bouton $submit
      await listen($submit, 'click')
      // On envoie le nouveau mot de passe
      return sendNewPassword
    })(),
  ])
}
```

[Promise.race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race) renvoie une promesse enveloppant la valeur de la promesse qui s'est terminÃ©e en premier. Si la seconde promesse est rÃ©solue postÃ©rieurement, elle est ignorÃ©e.

**Et voilÃ  comment on peut faire des applications spÃ©cifiÃ©es par un automateÂ !** C'est rigolo Ã  Ã©crire en plus.

Si vous Ãªtes curieux de voir une application qui utilise un automate de ce type, je suis actuellement en train de travailler sur [musixy, un gÃ©nÃ©rateur de playlist](https://github.com/GauBen/musixy). Comme beaucoup d'interactions sont possibles en mÃªme temps, **structurer cette application sous la forme d'un automate permet d'assurer qu'elle soit toujours dans un Ã©tat cohÃ©rent**.

[^escroc]:
    C'est un peu malhonnÃªte de ma part de ne pas l'Ã©crire avec le chaÃ®nage des promesses, mais c'est pour illustrer le problÃ¨me dans le cas des fonctions de rappel non chaÃ®nablesÂ :

    ```js
    window.addEventListener('load', () => {
      const $button = document.querySelector('#button')
      $button.addEventListener('click', () => {
        console.log('Hello World!')
      })
    })
    ```

    Les promesses sont mieux faites dans le sens oÃ¹ on peut les chaÃ®nerÂ :

    ```js
    sum(1, 2)
      /* Si la fonction de rappel renvoie une promesse... */
      .then((x) => sum(x, 3))
      /* ... alors on peut chaÃ®ner les `then` */
      .then((y) => {
        console.log(y)
      })
    ```

    On retrouve le chaÃ®nage dans l'exemple avec `fetch`.

[^listen.ts]: La mÃªme fonction, mais typÃ©e correctementÂ :

    ```ts
    export const listen = async <K extends keyof HTMLElementEventMap>(
      element: HTMLElement,
      eventName: K
    ) =>
      new Promise<HTMLElementEventMap[K]>((resolve) => {
        element.addEventListener(
          eventName,
          (event) => {
            resolve(event)
          },
          { once: true }
        )
      })
    ```

    Notez par ailleurs que, mÃªme si la fonction renvoie explicitement un objet `Promise`, elle est dÃ©clarÃ©e asynchrone. Ceci n'est pas une erreur, mais une recommandation donnÃ©e par `@typescript-eslint/promise-function-async`.

[^spoiler]: Je laisse un petit temps pour ne pas _spoiler_ la solution.
[^xmlhttprequest]: On peut avec `XMLHttpRequest`, mais c'est pas aussi agrÃ©able Ã  utiliser que `fetch`.
[^boucle]: On peut faire une boucle infinie pour attendre une date donnÃ©e, mais ce n'est ni Ã©lÃ©gant, ni performant.
[^module]: Alors on pourra Ã©crireÂ :

    ```html
    <script type="module">
      const sum = async (a, b) => {
        return a + b
      }
      let x = await sum(1, 2)
      let y = await sum(x, 3)
      console.log(y)
    </script>
    ```
